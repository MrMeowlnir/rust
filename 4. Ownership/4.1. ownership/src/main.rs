fn main() {
    let s = String::from("hello");  // s входит в область видимости

    takes_ownership(s);             // Значение s переносится в функцию...
                                    // ... и больше не доступно в этой области видимости
    let s1 = String::from("Hello!");  // s1 входит в облатсть видимости main
    let s2 = takes_and_gives_back(s1);  // s1 переходит в область видимости функции
                                              // s2 входит в область видимости main
    let (s3, len) = calculate_length(s2);
    println!("Длина строки '{s3}': {len} символов.");

    let x = 5;                      // x взодит в область видимости

    makes_copy(x);                  // x передается в функцию,
                                    // но тип i32 "Копируемый", таким образом
                                    // можно использовать x далее в этой области видимости

} // Здесь, x выходит из области видимости, затем - s. Но значение s уже было перемещено,
  // поэтому с ним ничего не произойдет

fn takes_ownership(some_string: String) { // some_string входит в область видимости функции
    println!("{some_string}");
} // some_string выходит из области видимости и вызывается метод `drop`.
  // Память освобождается.

fn makes_copy(some_integer: i32) { // some_integer входит в область видимости
    println!("{some_integer}");
} // some_integer выходит из области видимости.
// Никакие действия не требуются, потому что i32 - "Копируемый" тип.

// Функция которая принимает переменную и возвращает ее обратно
fn takes_and_gives_back(a_string: String) -> String { // a_string входит в область видимости
    a_string  // a_string возвращается функией и выходит из ее области видимости
}

fn calculate_length(s: String) -> (String, usize){ // s переходит в область видимости функции
    let length = s.len();   // length получает значение длины s

    (s, length)  // return функции в виде tuple (исходная строка, и ее длина)
    // обе переменные выходят из области видимости функции после return
}